{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # 1 bit full adder ALU performing addition operation\
def full_Adder(A,B,M1,M0):\
    out = []\
    C = 0\
    C_out = [0]\
    i = len(A) - 1\
    j = len(B) - 1\
    while i >= 0:\
        while j >= 0:\
            sum_out = ((A[i] ^ B[j]) ^ C)\
            #print(sum_out)\
            out.append(sum_out)\
            #print(sum_out, C)\
            c = (A[i] or B[j]) and (B[j] or C) and (A[i] or C)\
            \
            C = c\
            C_out.append(C)\
            #print(sum_out, C)\
            i -= 1\
            j -= 1\
    del(C_out[-1])\
    out.reverse()\
    C_out.reverse()\
    return out \
#     Dont return for now C_out\
    #print("And output =", out)\
    \
A = [1,0,1,0,1]\
B = [0,1,0,1,0]       \
#A = [0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1]\
#B = [1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0]\
# M1 = 1\
# M0 = 1\
full_Adder(A, B, M1, M0)\
\
# Python program to implement 1 bit ALU\
\
def onebit_ALU(A, B, M1, M0):\
    i = len(A)-1\
    j = len(B)-1\
    while i > 0:\
        while j > 0:\
        \
    \
            # Calculating AND gate\
            out_and = A and B\
\
            # Calculating Or gate\
            out_or = A or B\
\
            # Performing addition operation\
            out_add = full_Adder(A, B, M1, M0)\
            \
            i -= 1\
            j -= 1\
\
        #     # print the values\
        #     print("And output =", out_and)\
        #     print("Or output = ", out_or)\
        #     print("Addition =", out_add )\
\
    return out_add\
\
# Driver code\
# A = [1,1,1,1,1]\
# B = [0,1,0,1,0]\
# M1 = 1\
# M0 = 0\
onebit_ALU(A, B, M1, M0)\
\
def out_sum(A, B):\
        return (A ^ B)\
    \
A = 1\
B = 1\
out_sum(A, B)\
\
def out_and(A, B):\
    return A and B\
\
A = 0\
B = 0\
\
out_and(A, B)    \
\
def out_or(A, B):\
    return A or B\
\
A = 0\
B = 0\
\
out_or(A, B)   \
\
def out_Xor(A, B):\
    return A ^ B\
\
A = 1\
B = 0\
\
out_Xor(A, B)   # Python program for Multiplexer\
\
def multi(M1, M0):\
    if M1 == 0 and M0 == 0:\
        return(out_sum(A, B, C_in))\
    elif M1 == 1 and M0 == 0:\
        return(out_and(A, B))\
    elif M1 == 0 and M0 == 1:\
        return(out_or(A, B))\
    elif M1 == 1 and M0 == 1:\
        return(out_Xor(A, B))\
        \
    \
M1 = 1\
M0 = 1\
\
multi(M1, M0)# 16 bit ALU performing addition operation\
def six_adi(A,B, M1, M0):\
    out = []\
    C = 0\
    i = len(A) - 1\
    j = len(B) - 1\
    while i >= 0:\
        while j >= 0:\
            out = onebit_ALU(A,B, M1, M0) \
            i -= 1\
            j -= 1\
    return out\
# A = [0,1,0,1,0,0]\
# B = [1,1,1,1,1,0]\
# M1 = 1\
# M0 = 1\
# A = [0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1]\
# B = [1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0]\
\
six_adi(A, B, M1, M0)\
\
\
def b_inv(A,B,M0,M1):                                      # Function to invert B\
    B_inv = [] \
    i = len(B) - 1\
#     print("B is",i)\
    while i >= 0:\
        if B[i] == 0:\
            B_inv.append(1)\
            i -=1\
        else:\
            B_inv.append(0)\
            i -=1\
\
#     print(B_inv)        \
    B_inv.reverse()\
    del(B_inv[-1])\
\
#    print("Inverse of B is", B_inv)\
    return B_inv\
\
\
\
b_inv(A,B,M1,M0)\
\
# A = [0,0,0,0,0,0,0]\
# B = [1,0,1,0,1,0,1]\
\
\
def two_comp(A,B,M0,M1):\
    \
    one = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\
    print(one)\
    #print("inverse of b is",C)\
#    Bin = b_inv(A,B,M1,M0)\
#    print("Bin is",Bin)\
    two_out = full_Adder(Bin,one,M0,M1)\
#    print(two_out)\
    return two_out\
\
# A = [0,0,0,0]\
#B = [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1]\
\
# A = [0, 0, 0, 0, 0, 0]\
# B = [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]\
# M1 = 1\
# M0 = 1\
two_comp(A,B,M1,M0)\
\
\
# Robertson Fuction if MD is positive and negative for 16 bits(Final robertson)\
\
def robertson(A, B, M1, M0):\
    b = []\
    temp = []\
    temp_AC = []\
    temp_B = []\
    AC = [0]*16\
    FF = 0\
    \
    if A[0] == 0:\
        \
\
        i = len(A)-1\
        j = len(B)-1\
        while i > 0:\
            while j > 0:\
                if B[15] == 1:\
                    print("A , AC , B is ", AC, B)\
\
                    AC = six_adi(A, AC, M1, M0)\
    #                 print("A is ", A)\
    #                 print("AC is ",AC)\
                    print(AC,B)\
                    if B[15] == 1:\
\
\
\
    #                    FF = 1\
                        temp.append(FF)\
    #                print("temp is",temp)\
                        AC.reverse()\
                        AC.append(FF)\
                        AC.reverse()\
                        temp_AC = AC[-1]\
                        del(AC[-1])\
    #                 print("AC and B is ",AC,B)\
                        for k in (AC):\
                        #print(k)\
                            temp.append(k)\
    #                 print("temp is",temp)\
    #                 print(temp[-1])\
                        B.reverse()                                  # Shifting of B\
                        B.append(temp_AC)\
                        B.reverse()\
                        del(B[-1])\
    #                 print("B is",B)\
                        print("A , AC , B is ", AC, B)\
\
                        print("Cycle count is",i)\
                        i -= 1\
                        j -= 1\
                        print(i)\
\
                else:\
\
                    if B[15] == 0:\
                        AC.reverse()\
                        AC.append(FF)\
                        AC.reverse()                                  # Perfect AC with extra digit\
\
                        temp_B = (AC[-1])                         # temp_B will have last digit of AC\
                        print("AC is ",temp_B)\
                        del(AC[-1])\
    #                     print(AC)\
    #                     print(B)\
\
                        B.reverse()\
                        B.append(temp_B)\
                        B.reverse()                                   # Perfect B with extra digit                          \
                        del(B[-1])\
                        print("new AC and B is ", AC, B)\
\
                        print("Cycle Count is",i)\
                        i -= 1\
                        j -= 1\
#                        print(i)\
    \
    else:\
        \
        \
        i = len(A)-1\
    j = len(B)-1\
    while i > 0:\
        while j > 0:\
            if B[15] == 1:\
                print("A , AC , B is ", AC, B)\
                \
                AC = six_adi(A, AC,  M1, M0)\
#                 print("A is ", A)\
#                 print("AC is ",AC)\
                print(AC,B)\
                if B[15] == 1:\
            \
            \
            \
                    FF = 1\
                    temp.append(FF)\
#                print("temp is",temp)\
                    AC.reverse()\
                    AC.append(FF)\
                    AC.reverse()\
                    temp_AC = AC[-1]\
                    del(AC[-1])\
#                 print("AC and B is ",AC,B)\
                    for k in (AC):\
                    #print(k)\
                        temp.append(k)\
#                 print("temp is",temp)\
#                 print(temp[-1])\
                    B.reverse()                                  # Shifting of B\
                    B.append(temp_AC)\
                    B.reverse()\
                    del(B[-1])\
#                 print("B is",B)\
                    print("A , AC , B is ", AC, B)\
\
                    print("Cycle Count is ",i)\
                    i -= 1\
                    j -= 1\
        \
            else:\
                \
                if B[15] == 0:\
                    AC.reverse()\
                    AC.append(FF)\
                    AC.reverse()                                  # Perfect AC with extra digit\
                    \
                    temp_B = (AC[-1])                         # temp_B will have last digit of AC\
                    print("AC is ",temp_B)\
                    del(AC[-1])\
#                     print(AC)\
#                     print(B)\
                    \
                    B.reverse()\
                    B.append(temp_B)\
                    B.reverse()                                   # Perfect B with extra digit                          \
                    del(B[-1])\
                    print("new AC and B is ", AC, B)\
\
                    print("Cycle count is",i)\
                    i -= 1\
                    j -= 1\
#                    print(i)\
    \
    print("AC and B is",AC,B)\
    prod = AC + B\
    print("product is",prod)\
    inverse = []\
    \
    if prod[-1] == 0:\
        print("nod need to take 2's compliment of number",prod)\
        del(prod[-1])\
        print("Answer of 2 product if MQ is negative and MQ0 is 0 is",prod)\
    else:\
        inverse = b_inv(A,prod,M1,M0)\
        print("inverse is-----",inverse)\
        \
#         inverse = []\
#         for m in range(0,len(prod)-1):\
#             if prod[m] == 1:\
#                 inverse.append(0)\
#             else:\
#                 inverse.append(1)\
#         print("inverse is",inverse)\
#         print("1's compliment of no is(inverse)",inverse)\
        print("-------")\
#         one_1 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]    # Function for 2's compliment\
#         inverse_1 = []\
#         inverse_1 = two_comp(one_1,inverse,M1,M0)\
#         print("Inverse_1 is ",inverse_1)\
\
        one = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\
\
\
        if inverse[-1] == 0:\
            inverse_1 = six_adi(inverse,one,  M1, M0)\
\
        else:\
            inverse_1 = six_adi(inverse,one,  M1, M0)\
\
        print("2's compliment of no is",inverse_1)\
\
# Driver Code(Main Function)            \
\
A = [0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1]\
B = [1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0]\
# A = [1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0]   \
# B = [0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1]\
# A = [1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,0]\
# B = [1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0]\
M1 = 1\
M0 = 1\
robertson(A, B, M1, M0)}